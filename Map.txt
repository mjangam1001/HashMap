Map Interface	:
			-> Not a child interface of collection interface
			-> Key-Value Pair
			-> Collection of entries
			-> Duplicate keys are not allowed
			-> Duplicate values can be used


HashMap		:
			-> Same as hashtable but it is unsynchronized
			-> Uses Hashing of keys
			-> Null Key and null values are allowed
			
			Functions
			
			- public object put(object key, object value)
			- public object get(object key)
			- public object remove(object key)
			- public boolean containsKey(object key) 
			- public boolean containsValue(object value) 
			- public int size();
			- public boolean isEmpty()
			- public void clear()

			collection views of map
			- public Set keySet()
			- public Set entrySet()
			- public Collection values()

			- public void putAll(Map map)
			
	
			interface map
				interface entry //inner interface
			entry specific method
			- getKey,getValues,setValue(Object new)
			

public interface java.util.Map<K, V> {
  //public abstract int size();
  //public abstract boolean isEmpty();
  //public abstract boolean containsKey(java.lang.Object);
  public abstract boolean containsValue(java.lang.Object);
  public abstract V get(java.lang.Object);
  public abstract V put(K, V);
  public abstract V remove(java.lang.Object);
  public abstract void putAll(java.util.Map<? extends K, ? extends V>);
  public abstract void clear();
  public abstract java.util.Set<K> keySet();
  public abstract java.util.Collection<V> values();
  public abstract java.util.Set<java.util.Map$Entry<K, V>> entrySet();
  public abstract boolean equals(java.lang.Object);
  public abstract int hashCode();
  public V getOrDefault(java.lang.Object, V);
  public void forEach(java.util.function.BiConsumer<? super K, ? super V>);
  public void replaceAll(java.util.function.BiFunction<? super K, ? super V, ? extends V>);
  public V putIfAbsent(K, V);
  public boolean remove(java.lang.Object, java.lang.Object);
  public boolean replace(K, V, V);
  public V replace(K, V);
  public V computeIfAbsent(K, java.util.function.Function<? super K, ? extends V>);
  public V computeIfPresent(K, java.util.function.BiFunction<? super K, ? super V, ? extends V>);
  public V compute(K, java.util.function.BiFunction<? super K, ? super V, ? extends V>);
  public V merge(K, V, java.util.function.BiFunction<? super V, ? super V, ? extends V>);
  public static <K, V> java.util.Map<K, V> of();
  public static <K, V> java.util.Map<K, V> of(K, V);
  public static <K, V> java.util.Map<K, V> of(K, V, K, V);
  public static <K, V> java.util.Map<K, V> of(K, V, K, V, K, V);
  public static <K, V> java.util.Map<K, V> of(K, V, K, V, K, V, K, V);
  public static <K, V> java.util.Map<K, V> of(K, V, K, V, K, V, K, V, K, V);
  public static <K, V> java.util.Map<K, V> of(K, V, K, V, K, V, K, V, K, V, K, V);
  public static <K, V> java.util.Map<K, V> of(K, V, K, V, K, V, K, V, K, V, K, V, K, V);
  public static <K, V> java.util.Map<K, V> of(K, V, K, V, K, V, K, V, K, V, K, V, K, V, K, V);
  public static <K, V> java.util.Map<K, V> of(K, V, K, V, K, V, K, V, K, V, K, V, K, V, K, V, K, V);
  public static <K, V> java.util.Map<K, V> of(K, V, K, V, K, V, K, V, K, V, K, V, K, V, K, V, K, V, K, V);
  public static <K, V> java.util.Map<K, V> ofEntries(java.util.Map$Entry<? extends K, ? extends V>...);
  public static <K, V> java.util.Map$Entry<K, V> entry(K, V);
  public static <K, V> java.util.Map<K, V> copyOf(java.util.Map<? extends K, ? extends V>);
}

hashmap
underlying data structure is hash table
insertion order not preserverd and based on hashcode of keys
duplicate keys are not allowed , values are
heterogeneous keys values allowed
implements serializable and clonabel interface but not random access
best choice for search

hashmap constructors
1. hashmap m = new hashmap
default capacity 16 
default fill ratio 0.75

2. hashmap m = new hashmap(int initialcap)

3. hashmap m = new hashmap(int initialcap,float fillratio)

4. hashmap m = new hashmap(map m)

diff betn 
hashmap		hashtable
not synchrinizes 	synchrinized
not thread safe		thread safe
high performance	low performance
null key value		null key value not allowed
not legecay		legacy


linked hashmap
same as hashmap (including methods and constructors)
childe of hashmap

hashmap				linkedhashmap
underlying data strucutr is hastable	hashtable+linkedlist(hybrid)
insertion order is not preserved	insertion order is preserved
&based on hashcode of keyset
1.2v					1.4v

linked hashset nad linked hashmap used for develpoing cache based applications

for synchronized version of hashmap we can use synchronizedmap method of collections class

identityhashmap
jvm uses .equals for hashmap
jvm uses == for identityhashmap
if we replace hashmap with identity hashmap , 

weak hashmap


clone method

The clone() method saves the extra processing task for creating the exact copy of an object. If we perform it by using the new keyword, it will take a lot of processing time to be performed that is why we use object cloning.

Advantage of Object cloning
Although Object.clone() has some design issues but it is still a popular and easy way of copying objects. Following is a list of advantages of using clone() method:

You don't need to write lengthy and repetitive codes. Just use an abstract class with a 4- or 5-line long clone() method.
It is the easiest and most efficient way for copying objects, especially if we are applying it to an already developed or an old project. Just define a parent class, implement Cloneable in it, provide the definition of the clone() method and the task will be done.
Clone() is the fastest way to copy array.
Disadvantage of Object cloning
Following is a list of some disadvantages of clone() method:

To use the Object.clone() method, we have to change a lot of syntaxes to our code, like implementing a Cloneable interface, defining the clone() method and handling CloneNotSupportedException, and finally, calling Object.clone() etc.
We have to implement cloneable interface while it doesn't have any methods in it. We just have to use it to tell the JVM that we can perform clone() on our object.
Object.clone() is protected, so we have to provide our own clone() and indirectly call Object.clone() from it.
Object.clone() doesn't invoke any constructor so we don't have any control over object construction.
If you want to write a clone method in a child class then all of its superclasses should define the clone() method in them or inherit it from another parent class. Otherwise, the super.clone() chain will fail.
Object.clone() supports only shallow copying but we will need to override it if we need deep cloning.

Shallow copy copies the primitive values as it is but for reference type it copies reference to the object and doesnt create the new object. Meanwhile in deep copy you can override the clone() method to copy the exact values in the new object you create which is deep copy